1) Assinale a alternativa correta:

```
a) ( ) TreeSet não mantém a ordem de inserção
b) ( ) TreeSet é permite a reordenação, por isso é mais performático
c) ( ) TreeSet é performático para leitura, e mais lento para modificação pois não mantém a ordem de inserção
d) (x) TreeSet é performático para leitura, e mais lento para modificação pois tem a necessidade de reordenar após cada alteração
e) ( ) TreeSet é lento para leitura, e performático para modificação pois permite a reordenação
```

2) Dado o HashSet de números: [4, 2, 23, 14, 55], responder: Qual o estado resultante após a chamada do método 'numeros.set(33)'?

```
a) (x) Erro de compilação
b) ( ) [33, 4, 2, 23, 14, 55]
c) ( ) [4, 2, 23, 14, 55]
d) ( ) [4, 2, 23, 14, 55, 33]
e) ( ) Erro de execução
```

3) Dado o HashSet de números: [4, 2, 23, 14, 55], responder: Qual o estado resultante após a chamada do método 'numeros.add(23)'?

```
a) ( ) Erro de compilação
b) (x) [4, 2, 23, 14, 55]
c) ( ) Erro de execução
d) ( ) [4, 2, 14, 55]
e) ( ) [4, 2, 14, 55, 23]
```

4) Assinale a alternativa correta:

```
a) ( ) LinkedHashSet não mantém a ordem dos elementos, mas permite reordenação
b) ( ) LinkedHashSet não deve ser utilizado em cenários onde é necessário manter a ordem dos elementos
c) ( ) LinkedHashSet deve ser utilizado em cenários onde é necessário reordenar os elementos

d) (x) LinkedHashSet deve ser utilizado em cenários onde é necessário manter a ordem dos elementos
e) ( ) LinkedHashSet é performático para inserção e remoção de elementos, porém é lento para leitura
```

5) Dado o HashSet de números: [4, 2, 23, 14, 55], responder: Qual o estado resultante após a chamada do método 'numeros.add(null)'?

```
a) ( ) Erro de execução
b) ( ) [null, 4, 2, 23, 14, 55]
c) (x) [4, 2, 23, 14, 55, null]
d) ( ) [4, 2, 23, 14, 55]
e) ( ) Erro de compilação
```

6) Dado o TreeSet de cidades inserido na seguinte ordem: "Porto Alegre", "Florianópolis", "Curitiba", "São Paulo", "Rio de Janeiro", assinale a alternativa incorreta?

```
a) ( ) 'cidades.first()' retornará "Curitiba"
b) (x) 'cidades.higher("Florianópolis")' retornará "Curitiba"
c) ( ) 'cidades.higher("Florianópolis")' retornará "Porto Alegre"
d) ( ) 'cidades.lower("Florianópolis")' retornará "Curitiba"
e) ( ) 'cidades.last()' retornará "São Paulo"
```

7) Dado o HashSet de números: [4, 2, 23, 14, 55], responder: Qual o estado resultante após a chamada do método 'Collections.sort(numeros)'?

```
a) ( ) [4, 2, 23, 14, 55]
b) (x) Erro de execução
c) ( ) [55, 23, 14, 4, 2]
d) ( ) [2, 4, 14, 23, 55]
e) ( ) Erro de compilação
```

8) Dado o HashSet de números: [4, 2, 23, 14, 55], responder: Qual o estado resultante após a chamada do método 'numeros.add(44)'?

```
a) ( ) [44, 4, 2, 23, 14, 55]
b) ( ) [44]
c) ( ) Erro de compilação
d) ( ) Erro de execução
e) (x) [4, 2, 23, 14, 55, 44]
```

9) Assinale a alternativa correta:

```
a) ( ) HashSet não garante a ordem de inserção, não permite a reordenação, por isso é mais lento
b) ( ) HashSet garante a ordem de inserção, mas não permite reordenação, por isso é mais performático
c) ( ) HashSet não garante a ordem de inserção, permite a reordenação, por isso é mais performático
d) (x) HashSet não garante a ordem de inserção, não permite a reordenação, por isso é mais performático
e) ( ) HashSet não garante a ordem de inserção, não permite a reordenação, por isso é mais lento
```

10) Dado o TreeSet de cidades inserido na seguinte ordem: "Porto Alegre", "Florianópolis", "Curitiba", "São Paulo", "Rio de Janeiro", qual o resultado da chamada: 'System.out.println(cidades)'?

```
a) ( ) null
b) ( ) Erro de execução
c) (x) [Curitiba, Florianópolis, Porto Alegre, Rio de Janeiro, São Paulo]
d) ( ) [Rio de Janeiro, São Paulo, Curitiba, Florianópolis, Porto Alegre]
e) ( ) [Porto Alegre, Florianópolis, Curitiba, São Paulo, Rio de Janeiro]
```

